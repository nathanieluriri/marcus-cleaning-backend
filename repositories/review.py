# ============================================================================
# REVIEW REPOSITORY
# ============================================================================
# This file was auto-generated on: 2026-02-24 11:47:20 WAT
# It contains asynchronous functions for managing access to the database
# in a MongoDB database using FastAPI.
#
# DO NOT EDIT THIS FILE MANUALLY - RE-RUN THE GENERATOR INSTEAD. OR IF YOU WANT TO EDIT JUST ADD LEAVE OTHER FUNCTIONS THE WAY YOU MET THEM
# ============================================================================

from pymongo import ReturnDocument
from core.database import db
from fastapi import HTTPException,status
from typing import List,Optional
from schemas.review import RatingBreakdown, ReviewRatingSummary, ReviewUpdate, ReviewCreate, ReviewOut

async def create_review(review_data: ReviewCreate) -> ReviewOut:
    review_dict = review_data.model_dump()
    result =await db.reviews.insert_one(review_dict)
    await db.reviews.create_index(
        [("cleaner_id", 1)],  # 1 = ascending, -1 = descending
        name="idx_cleaner_id"
    )
    result = await db.reviews.find_one(filter={"_id":result.inserted_id})
    returnable_result = ReviewOut(**result) # type: ignore
    return returnable_result

async def get_review(filter_dict: dict) -> Optional[ReviewOut]:
    try:
        result = await db.reviews.find_one(filter_dict)

        if result is None:
            return None

        return ReviewOut(**result)

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching review: {str(e)}"
        )
    
async def get_reviews(filter_dict: dict | None = None,start: int = 0,stop: int = 100) -> List[ReviewOut]:
    try:
        if filter_dict is None:
            filter_dict = {}

        cursor = (db.reviews.find(filter_dict)
        .skip(start)
        .limit(stop - start)
        )
        review_list = []

        async for doc in cursor:
            review_list.append(ReviewOut(**doc))

        return review_list

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching reviews: {str(e)}"
        )
async def update_review(filter_dict: dict, review_data: ReviewUpdate) -> ReviewOut | None:
    result = await db.reviews.find_one_and_update(
        filter_dict,
        {"$set": review_data.model_dump(exclude_none=True)},
        return_document=ReturnDocument.AFTER
    )
    if result is None:
        return None
    return ReviewOut(**result)

async def delete_review(filter_dict: dict):
    return await db.reviews.delete_one(filter_dict)




async def review_summary_aggregation(cleaner_id: str)->ReviewRatingSummary:
    pipeline = [
        {"$match": {"cleaner_id": cleaner_id}},
        {
            "$facet": {
                "summary": [
                    {
                        "$group": {
                            "_id": None,
                            "average_rating": {"$avg": "$stars"},
                            "total_ratings": {"$sum": 1}
                        }
                    }
                ],
                "breakdown": [
                    {
                        "$group": {
                            "_id": "$stars",
                            "count": {"$sum": 1}
                        }
                    }
                ]
            }
        }
    ]

    result = await db.reviews.aggregate(pipeline).to_list(length=1)
    if not result:
        # No reviews found
        flattened_summary = {"average_rating": 0.0, "total_ratings": 0}
        flattened_breakdown = {f"{star}_star": 0 for star in ["one","two","three","four","five"]}
    else:
        summary_data = result[0]["summary"][0] if result[0]["summary"] else {}
        flattened_summary = {
            "average_rating": summary_data.get("average_rating", 0.0),
            "total_ratings": summary_data.get("total_ratings", 0)
        }

        breakdown_data = result[0]["breakdown"]
        star_map = {1: "one_star", 2: "two_star", 3: "three_star", 4: "four_star", 5: "five_star"}
        flattened_breakdown = {f"{star}_star": 0 for star in ["one","two","three","four","five"]}

        for item in breakdown_data:
            key = star_map.get(item["_id"])
            if key:
                flattened_breakdown[key] = item["count"]

    breakdown_model = RatingBreakdown(**flattened_breakdown)
    summary_model = ReviewRatingSummary(
        **flattened_summary,
        rating_breakdown=breakdown_model
    )

    return summary_model