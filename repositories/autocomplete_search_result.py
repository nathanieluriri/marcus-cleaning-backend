# ============================================================================
# AUTOCOMPLETE_SEARCH_RESULT REPOSITORY
# ============================================================================
# This file was auto-generated on: 2026-02-23 20:21:53 WAT
# It contains asynchronous functions for managing access to the database
# in a MongoDB database using FastAPI.
#
# DO NOT EDIT THIS FILE MANUALLY - RE-RUN THE GENERATOR INSTEAD. OR IF YOU WANT TO EDIT JUST ADD LEAVE OTHER FUNCTIONS THE WAY YOU MET THEM
# ============================================================================

from pymongo import ReturnDocument
from core.database import db
from fastapi import HTTPException,status
from typing import List,Optional
from schemas.autocomplete_search_result import AutocompleteSearchResultUpdate, AutocompleteSearchResultCreate, AutocompleteSearchResultOut

async def create_autocomplete_search_result(autocomplete_search_result_data: AutocompleteSearchResultCreate) -> AutocompleteSearchResultOut:
    autocomplete_search_result_dict = autocomplete_search_result_data.model_dump()
    result =await db.autocomplete_search_results.insert_one(autocomplete_search_result_dict)
    result = await db.autocomplete_search_results.find_one(filter={"_id":result.inserted_id})
    returnable_result = AutocompleteSearchResultOut(**result)
    return returnable_result

async def get_autocomplete_search_result(filter_dict: dict) -> Optional[AutocompleteSearchResultOut]:
    try:
        result = await db.autocomplete_search_results.find_one(filter_dict)

        if result is None:
            return None

        return AutocompleteSearchResultOut(**result)

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching autocomplete_search_result: {str(e)}"
        )
    
async def get_autocomplete_search_results(filter_dict: dict | None = None,start: int = 0,stop: int = 100) -> List[AutocompleteSearchResultOut]:
    try:
        if filter_dict is None:
            filter_dict = {}

        cursor = (db.autocomplete_search_results.find(filter_dict)
        .skip(start)
        .limit(stop - start)
        )
        autocomplete_search_result_list = []

        async for doc in cursor:
            autocomplete_search_result_list.append(AutocompleteSearchResultOut(**doc))

        return autocomplete_search_result_list

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching autocomplete_search_results: {str(e)}"
        )
async def update_autocomplete_search_result(filter_dict: dict, autocomplete_search_result_data: AutocompleteSearchResultUpdate) -> AutocompleteSearchResultOut | None:
    result = await db.autocomplete_search_results.find_one_and_update(
        filter_dict,
        {"$set": autocomplete_search_result_data.model_dump(exclude_none=True)},
        return_document=ReturnDocument.AFTER
    )
    if result is None:
        return None
    return AutocompleteSearchResultOut(**result)

async def delete_autocomplete_search_result(filter_dict: dict):
    return await db.autocomplete_search_results.delete_one(filter_dict)