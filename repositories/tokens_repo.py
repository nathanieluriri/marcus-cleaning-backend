from __future__ import annotations

from datetime import datetime, timedelta, timezone

from bson import ObjectId, errors
from dateutil import parser
from fastapi import HTTPException

from core.database import db
from repositories.admin_repo import get_admin
from schemas.tokens_schema import accessTokenCreate, accessTokenOut, refreshTokenCreate, refreshTokenOut
from security.encrypting_jwt import decode_jwt_token, decode_jwt_token_without_expiration

# Auto-generated by fasterapi make-token-repo on: 2026-02-22T23:22:54.413656+00:00
# Roles: admin, cleaner, customer


async def add_admin_access_token(token_data: accessTokenCreate) -> accessTokenOut:
    token = token_data.model_dump()
    token['role'] = 'admin'
    token['status'] = 'active'
    result = await db.accessToken.insert_one(token)
    created = await db.accessToken.find_one({"_id": result.inserted_id})
    return accessTokenOut(**created)


async def activate_admin_access_token(token_id: str) -> accessTokenOut:
    updated = await db.accessToken.find_one_and_update(
        filter={"_id": ObjectId(token_id), "role": "admin"},
        update={"$set": {"status": "active"}},
        return_document=True,
    )
    if not updated:
        raise HTTPException(
            status_code=404,
            detail="Admin token not found or role mismatch",
        )
    return accessTokenOut(**updated)

async def add_cleaner_access_token(token_data: accessTokenCreate) -> accessTokenOut:
    token = token_data.model_dump()
    token['role'] = 'cleaner'

    result = await db.accessToken.insert_one(token)
    created = await db.accessToken.find_one({"_id": result.inserted_id})
    return accessTokenOut(**created)


async def activate_cleaner_access_token(token_id: str) -> accessTokenOut:
    updated = await db.accessToken.find_one_and_update(
        filter={"_id": ObjectId(token_id), "role": "cleaner"},
        update={"$set": {"status": "active"}},
        return_document=True,
    )
    if not updated:
        raise HTTPException(
            status_code=404,
            detail="Cleaner token not found or role mismatch",
        )
    return accessTokenOut(**updated)

async def add_customer_access_token(token_data: accessTokenCreate) -> accessTokenOut:
    token = token_data.model_dump()
    token['role'] = 'customer'

    result = await db.accessToken.insert_one(token)
    created = await db.accessToken.find_one({"_id": result.inserted_id})
    return accessTokenOut(**created)


async def activate_customer_access_token(token_id: str) -> accessTokenOut:
    updated = await db.accessToken.find_one_and_update(
        filter={"_id": ObjectId(token_id), "role": "customer"},
        update={"$set": {"status": "active"}},
        return_document=True,
    )
    if not updated:
        raise HTTPException(
            status_code=404,
            detail="Customer token not found or role mismatch",
        )
    return accessTokenOut(**updated)


async def add_access_tokens(token_data: accessTokenCreate) -> accessTokenOut:
    return await add_cleaner_access_token(token_data=token_data)


async def add_admin_access_tokens(token_data: accessTokenCreate) -> accessTokenOut:
    return await add_admin_access_token(token_data=token_data)


async def update_admin_access_tokens(token: str) -> accessTokenOut:
    return await activate_admin_access_token(token_id=token)


async def add_refresh_tokens(token_data: refreshTokenCreate) -> refreshTokenOut:
    token = token_data.model_dump()
    result = await db.refreshToken.insert_one(token)
    created = await db.refreshToken.find_one({"_id": result.inserted_id})
    return refreshTokenOut(**created)


async def add_refresh_token(token_data: refreshTokenCreate) -> refreshTokenOut:
    return await add_refresh_tokens(token_data=token_data)


async def delete_access_token(accessToken: str):
    await db.accessToken.find_one_and_delete({"_id": ObjectId(accessToken)})


async def delete_refresh_token(refreshToken: str):
    try:
        obj_id = ObjectId(refreshToken)
    except errors.InvalidId as err:
        raise HTTPException(status_code=401, detail="Invalid Refresh Id") from err

    result = await db.refreshToken.find_one_and_delete({"_id": obj_id})
    if result:
        return True
    return False


def is_older_than_days(date_value, days: int = 10) -> bool:
    if isinstance(date_value, (int, float)):
        created_date = datetime.fromtimestamp(date_value, tz=timezone.utc)
    else:
        created_date = parser.isoparse(str(date_value))

    now = datetime.now(timezone.utc)
    return (now - created_date) > timedelta(days=days)


async def _resolve_access_token_id(accessToken: str, allow_expired: bool) -> str | None:
    decoded = (
        await decode_jwt_token_without_expiration(accessToken)
        if allow_expired
        else await decode_jwt_token(accessToken)
    )
    if decoded and decoded.get("accessToken"):
        return decoded["accessToken"]

    try:
        ObjectId(accessToken)
        return accessToken
    except errors.InvalidId:
        return None


async def get_access_token(accessToken: str, allow_expired: bool = False) -> accessTokenOut | None:
    token_id = await _resolve_access_token_id(accessToken=accessToken, allow_expired=allow_expired)
    if not token_id:
        return None

    token = await db.accessToken.find_one({"_id": ObjectId(token_id)})
    if not token:
        return None

    if not allow_expired and is_older_than_days(date_value=token.get("dateCreated")):
        await delete_access_token(accessToken=str(token["_id"]))
        return None

    if token.get("role") == "admin" and token.get("status") != "active":
        return None

    return accessTokenOut(**token)


async def get_access_tokens(accessToken: str) -> accessTokenOut | None:
    return await get_access_token(accessToken=accessToken, allow_expired=False)


async def get_admin_access_tokens(accessToken: str) -> accessTokenOut | None:
    token = await get_access_token(accessToken=accessToken, allow_expired=False)
    if not token or token.role != "admin":
        return None

    user_id = token.userId
    if not user_id:
        return None

    if await get_admin(filter_dict={"_id": ObjectId(user_id)}):
        return token

    return None


async def get_inactive_access_token(token_id: str) -> accessTokenOut | None:
    try:
        obj_id = ObjectId(token_id)
    except errors.InvalidId:
        return None

    token = await db.accessToken.find_one({"_id": obj_id, "status": "inactive"})
    if token:
        return accessTokenOut(**token)
    return None


async def get_access_token_allow_expired(accessToken: str) -> accessTokenOut | None:
    return await get_access_token(accessToken=accessToken, allow_expired=True)


async def get_refresh_tokens(refreshToken: str) -> refreshTokenOut | None:
    token = await db.refreshToken.find_one({"_id": ObjectId(refreshToken)})
    if token:
        return refreshTokenOut(**token)
    return None


async def delete_access_and_refresh_token_with_user_id(userId: str) -> bool:
    result_refresh = await db.refreshToken.delete_many({"userId": userId})
    result_access = await db.accessToken.delete_many({"userId": userId})
    return result_refresh.acknowledged and result_access.acknowledged


async def delete_all_tokens_with_user_id(userId: str):
    await db.refreshToken.delete_many(filter={"userId": userId})
    await db.accessToken.delete_many(filter={"userId": userId})


async def delete_all_tokens_with_admin_id(adminId: str):
    await db.refreshToken.delete_many(filter={"userId": adminId})
    await db.accessToken.delete_many(filter={"userId": adminId})
